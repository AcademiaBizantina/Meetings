Participants: Popescu Lucian, Airinei Daniel

PL: Reflections on trusting trust

Key Ideas:
  * Trusting a computer system is based on the same principles as trusting another human being.
  * There are 5 strategies for trusting: optimist, pessimist, centralised, investigation, transitivity [1]
  * The stragety we used is dependant on the environment we try to apply the strategy in.
  * Can we force a computer system to never lie about the operation is runs?
  * At what abstraction level should the operations be formulated so that the computer can ensure us about their trustworthiness?
  * If we can't force the system not to lie then what approach should we take?

Questions:
  * Are trust issues greater/of more importance
in computer science than other areas 
of day to day life? 
  * To what extent can you prove trustworthiness?
  * To what extent do you need to prove turstworthiness?

References: \
[1] https://eprints.soton.ac.uk/260029/1/ISWC04-OHara-final.pdf Fig.1 \
https://dl.acm.org/doi/pdf/10.1145/800001.811674 \
https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf

AD: The End to the Myth of Individual Programmer Productivity[1]

Questions and Observations:
  * The fact that progammers can be tracked by their programming style is GDPR complaint?
  * What implications does the above question have to open-source code?
  * The fact that the same piece of information is repeated in a paper is not bad.
  This technique is used to help the reader have the necessary context.
  * The graph in the paper (I forgot which one because I don't have the paper ATM) does not have measurement units noted.
  * It would be great if we would implement this experiment to our courses to see where students perform better and where they perform worse.
  * Does the fact that the students were asked to log their performance during the test affect the results?
  * Why did they chose C developers for their test population? Choosing another language community would affect the results?
  * Why is it important to have developers focused on a specific language? Why didn't they focus on general computer science problems?
  * Why is the dataset they used for this experiment not open?
  * Is there a continuation of this study where one company (or multiple companies) tried to apply those advices? 


References: \
[1]https://ieeexplore.ieee.org/abstract/document/8804291?casa_token=vrLEnwGSrMQAAAAA:vP9zEeJMPFRauT-DsELQPpVgU7x4ay_TkAKMmcmjiHA1WdZlv1EJfD1JikG2SQrVhSw2u3pPmcRR
